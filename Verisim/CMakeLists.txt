cmake_minimum_required(VERSION 3.16)
project(verisim LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)

# Verilog code paths (if the are other .v files, add them here)
set(VERILOG_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/verilog/verisim.v
    # ${CMAKE_CURRENT_SOURCE_DIR}/verilog/other_files.v
)

# C++ source code paths (if the are other .cpp files, add them here)
set(CPP_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/src/verisim.cpp
    # ${CMAKE_CURRENT_SOURCE_DIR}/src/custom_logic.cpp
)

# Set the directory to output the compiled object files to
set(VERILATOR_OUTPUT_DIR ${CMAKE_BINARY_DIR}/verilated)

# The path to the header files (Some of them are auto generated by verilator)
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/include # function declarations
    ${CMAKE_CURRENT_SOURCE_DIR}/lib # header only libraries
    ${VERILATOR_OUTPUT_DIR}  # headers generated by verilator
)

# Run Verilator to generate C++
add_custom_command(
    OUTPUT ${VERILATOR_OUTPUT_DIR}/Vverisim.mk
    COMMAND verilator --cc ${VERILOG_SOURCES}
            --exe ${CPP_SOURCES}
            -Mdir ${VERILATOR_OUTPUT_DIR}
            -I${CMAKE_CURRENT_SOURCE_DIR}/include
            -trace
    DEPENDS ${VERILOG_SOURCES} ${CPP_SOURCES}
    COMMENT "Running Verilator..."
    VERBATIM
)

# Build the simulation (using the make file generated by verilator)
add_custom_command(
    OUTPUT ${VERILATOR_OUTPUT_DIR}/Vverisim
    COMMAND make -C ${VERILATOR_OUTPUT_DIR} -f Vverisim.mk
    DEPENDS ${VERILATOR_OUTPUT_DIR}/Vverisim.mk ${CPP_SOURCES} ${VERILOG_SOURCES}
    COMMENT "Building Verilated executable..."
    VERBATIM
)

# Create a target that represents the final executable
add_custom_target(run_verisim ALL
    DEPENDS ${VERILATOR_OUTPUT_DIR}/Vverisim
)

# Copy the executable to build/
add_custom_command(TARGET run_verisim POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy
            ${VERILATOR_OUTPUT_DIR}/Vverisim
            ${CMAKE_BINARY_DIR}/Vverisim
)
